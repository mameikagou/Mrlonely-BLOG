


pnpm 为什么完爆npm和yarn？
[PNPM]<https://juejin.cn/post/7127295203177676837>

### 公共依赖问题

- npm2
会循环嵌套依赖, 会把相同的包安装很多次。

- yarn、npm3
会把循环嵌套的依赖铺平，但是这样铺平之后就可能导致幽灵依赖（使用了没有声明的子包里的依赖）。

具体处理方式：
1. 将第一个遇到的提升到顶层
2. 版本冲突时，放在父依赖的顶层
3. 遵循node的模块解析算法，从当前目录的 `node_modules` 逐级往上查找；

```md
示例场景：

- 包A依赖 lodash@4
- 包B依赖 lodash@5
处理结果：
node_modules/
├── lodash@4（提升到顶层）
└── 包B/
    └── node_modules/
        └── lodash@5（嵌套安装）
```

有以下的问题：
1. `幽灵依赖`, 项目代码可能意外访问到顶层；
2. 依赖树结构不稳定，依赖安装顺序的不同可能导致结构变化；

### 

### pnpm link:
将一个包链接到全局node_modules目录下，这样就可以在全局使用这个包了；
比如，如何将本地包链接到全局；


### 硬链接-软链接
pnpm是通过使用硬链接，实现多个文件夹共用同一个全局文件`.pnpm/store`，从而大量减少磁盘消耗；
然后在node-modules下的`.pnpm`，通过软链接连接到各自目录下的`./pnpm/`，不允许使用未声明的依赖，从而避免幽灵依赖。

- tips: 注意区分全局下的`.pnpm`以及每个包自己的`.pnpm`

[pnpm](./image.png)

硬链接：文件的副本，占用磁盘空间（两个文件名，但是指向的同一份空间， 两个名都删除后， 才会删除文件数据。）
符号链接、软链接：快捷方式，不占用磁盘空间，仅仅是文件指针。

在npm和/yarn中，每个项目独立复制依赖文件，占用空间大; 
比较混乱，可能导致幽灵依赖和依赖冲突问题；


### pnpm patch

https://juejin.cn/post/6962554654643191815

就是可以打补丁然后改源码；

使用上述三种方式虽然能通过一些骚操作解决某些特定场景下的问题，但都无法避免版本升级带来的困扰，如果该npm包升级，可能会导致原先的修改产生错误，所以如果想使用上述三种办法，最好还是要将版本号写死。然而patch-package有如下特性：


- 版本试错
如果你装的包版本和你之前生成的补丁中记录的版本不一样，npx patch-package会直接报错**ERROR** Failed to apply patch for package xxxx at path，通过提示你可以更方便的定位问题

- 节省空间
使用git diff来记录补丁比起重写一份源码的方法更节省空间，即安全，又便捷