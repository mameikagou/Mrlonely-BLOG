## 微前端

[如何设计实现微前端框架](https://www.yuque.com/zaotalk/posts/dfqyh7)


简单来说，微前端就是把多个web应用聚合在一起，提供统一的访问入口；

给用户的观感就是一个统一的应用，但是背后的实现上可能用到不同的技术栈；

#### 优点：
- 技术栈无关
- 独立性强
- 状态隔离


#### 缺点：
- 子应用无法获取全局dom，割裂严重
- 应用之间通信困难
- 路由状态难以维护，容易丢失
- 每个spa的白屏加载时间长


有多个方案:
- iframe嵌入url，通信和路由管理比较困难；
- npm




### ReactRouter

一段基于ReactRouter动态导入组件的方案；
```ts
export const AyncComponent: React.FC<{ hotReload?: number; } & RouteComponentProps> = ({ location, hotReload }) => {
    // 子工程资源是否加载完成
    const [ayncLoaded, setAyncLoaded] = useState(false);
    // 子工程url配置信息是否加载完成
    const [subAppMapInfoLoaded, setSubAppMapInfoLoaded] = useState(false);
    const [ayncComponent, setAyncComponent] = useState(null);
    const { pathname } = location;
    // 取路径中标识子工程前缀的部分, 例如 '/subapp/xxx/index' 其中xxx即路由唯一前缀
    const id = pathname.split('/')[2];
    useEffect(() => {
        // 如果没有子工程配置信息, 则请求
        if (!subAppMapInfoLoaded) {
            fetchSubappUrlPath(id).then((data) => {
                subAppMapInfo = data;
                setSubAppMapInfoLoaded(true);
            }).catch((url: any) => {
                // 失败处理
                goBackToIndex();
            });
            return;
        }
        const subappModule = (subAppMapInfo as any)[id];
        if (subappModule) {
            if (subappRoutes[id]) {
                // 如果已经加载过该子工程的模块，则不再加载，直接取缓存的routes
                setAyncLoaded(true);
                setAyncComponent(subappRoutes[id]);
                return;
            }
            // 如果能匹配上前缀则加载相应子工程模块
            // 如果请求成功，则触发JSONP钩子window.wmadSubapp
            currentPrefix = id;
            setAyncLoaded(false);
            const jsUrl = subappModule.js;
            loadAsyncSubapp(jsUrl)
                .then(() => {
                    // 加载子工程完成
                    setAyncComponent(subappRoutes[id]);
                    setAyncLoaded(true);
                })
                .catch((urlList) => {
                    // 如果加载失败
                    setAyncLoaded(false);
                    console.log('loading failed...'); 
                });
        } else {
            // 可以重定向到首页去
            goBackToIndex();
        }
    }, [id, subAppMapInfoLoaded, hotReload]);
    return ayncLoaded ? ayncComponent : null;
};
```


### 解决方案 qiankun 以及 single-spa
qiankun通过动态加载和路由管理来实现微前端架构，路由切换的时候，它会加载或者卸载应用路由；

还解决了一些single-spa的问题，比如提供了css样式隔离以及js沙箱；

- 隔离css环境 ： shadowDOM隔离
- 隔离js环境：沙箱
- single-spa的缺口： 加载函数，js沙箱，css样式隔离


proxySandbox流程

就是用一个fakeWindow，当你更改子应用的window对象的时候，都会更改到fakeWindow；

fakeWindow没有的属性，就会去window上找给你；

[图片](./image.png)