#### 微前端
- 为什么选择微前端，
- 微前端的缺点（微前端性能一定就要比spa好吗），
- 微前端业务遇到哪些问题怎么解决
- 沙箱的作用（这里没答好）
- 样式污染怎么解决。
- 因为采用的框架是qiankun，问了还有哪些方案以及优劣。

1. 为什么选择微前端
- 多技术栈
- 大型应用，模块重复
- 提升业务内聚度（加上monorepo可以做到原子化的commit提交，而不必打开多个编辑区）
- 


higgs的优势：
- 不限制子应用技术栈
    - 单独管理包，可以使用不同的依赖
- 基于es6的proxy的js沙箱
- 基于发布订阅模式的全局通信
- css样式隔离，给子应用增加前缀
- 支持插件系统，注入一些全局变量和错误修复

基于microApp，提供了
- 依赖管理，可共享可独立
- 完善的路由共享，可以与uac鉴权相结合
- 完善的通信机制
- 使用microApp的js沙箱和样式隔离机制

3. 微前端的缺点和性能问题
- 一个包会多次加载，并且版本不一致，导致首屏时间加长
    - 使用webpack5的模块邦联模式，抽离公共依赖，建立公共模块，统一使用。
- 切换子应用有白屏如何解决？
    - 将公共模块从基座应用中读取，减少Bundle的体积
    - 子应用根节点加loading，等待Bundle完成后，再将真实节点挂在window下。


4. 沙箱机制的作用
- js作用域隔离，防止不同子应用之间的 JS 变量污染
- Proxy实现的沙箱机制

5. 样式污染怎么解决?
- 给子应用的样式增加前缀

6. 页面刚打开的时候刷重复请求

#### 微前端面经

- 沙箱的原理？
    - iframe
        - 隔离的比较好，但是通信比较困难
    - 非irame
        - JS沙箱：（JS 执行上下文和本地存储：通过全局快照或代理的方式，保存和恢复在应用获得控制权前后的全局状态）
            - window对象的快照，记录
            - 使用proxy对象代理
        - CSS沙箱
            - higgs，css全局增加前缀
            - shadow dom
- 子应用的通信机制？
    - window全局对象通信
    - postMessage通信


#### Webpack

- Webpack 的 Tree Shaking 是如何工作的？
- tree-shaking 原理是什么？
    - es6的模块的静态的，就是做静态分析，确定 ESM 模块中哪些导出值未曾其他模块使用，分析程序可达到的代码，消除无用代码。
- 如何确保tree-shaking生效？
    - 符合es6模块规范
    - 开启optimization.usedExports，启动标记功能
    - 启动代码优化
        - 开启production模式
        - 提供 `optimization.minimizer` 数组
    - 删除或者标记副作用（不要用立即执行函数），合理设置 sideEffects

- 使用lodash-es替代lodash，用dayjs代替moment