
### JS的 GC机制

- 新生代和老生代机制
    - 新生代：以空间换时间，所以有两个区域，追求“快”
        - 新生代会有两个区域，其中一个区域快满了就会触发一次GC，会把还在活跃的对象复制到另一个区域（确保精密排列，没有内存碎片），并且把原区域完全清除。
        - 经历了多次GC的对象，就会被放到老生代区域
    - 老生代：追求空间利用率，追求“稳”
        - 标记-清除：一样的计算可达性，删除不可达的对象。但是这样会产出碎片。
        - 整理：对之前的区域进行整理。
- GC判断机制，可达性判断
    - 会从根节点开始遍历，找到所有可达的对象。


#### 追问：
“除了闭包，你还知道哪些常见的 JavaScript 内存泄漏场景？”（例如：意外的全局变量、被遗忘的定时器 setInterval、DOM 节点的循环引用等）
“你用过哪些工具来检测和定位内存泄漏？”（例如：Chrome DevTools 的 Performance 和 Memory 面板）
“let 和 const 的出现，在多大程度上影响了我们对闭包的使用和理解？”（块级作用域使得在循环中不再需要 IIFE 来创建闭包了）
“你能解释一下 V8 引擎是如何优化闭包的吗？”（涉及到上下文（Context）和闭包对象（Closure Object）的优化，这是一个加分项）



##### WeakSet、WeakMap

- 不可迭代的，弱引用
    - 如果它支持迭代：WeakSet 的成员可能在任何时候被垃圾回收器（GC）清理掉。如果它支持迭代，那么 for...of 循环刚进行到一半，下一个成员可能就“人间蒸发”了。这会导致迭代结果完全不可预测，是一种混乱的状态
    - 从而从根本上杜绝这种不确定性。

- 这种特性导致了它不可迭代，因为其成员随时可能消失

- 当您需要为一个或多个外部对象的生命周期“附加”一些信息，而不想干涉它们的内存回收时（例如在框架或库中管理DOM节点状态），WeakSet 是绝佳选择。
