
### JS的 GC机制

- 新生代和老生代机制
    - 新生代：以空间换时间，所以有两个区域，追求“快”
        - 新生代会有两个区域，其中一个区域快满了就会触发一次GC，会把还在活跃的对象复制到另一个区域（确保精密排列，没有内存碎片），并且把原区域完全清除。
        - 经历了多次GC的对象，就会被放到老生代区域
    - 老生代：追求空间利用率，追求“稳”
        - 标记-清除：一样的计算可达性，删除不可达的对象。但是这样会产出碎片。
        - 整理：对之前的区域进行整理。
- GC判断机制，可达性判断
    - 会从根节点开始遍历，找到所有可达的对象。


#### 追问：
“除了闭包，你还知道哪些常见的 JavaScript 内存泄漏场景？”（例如：意外的全局变量、被遗忘的定时器 setInterval、DOM 节点的循环引用等）
“你用过哪些工具来检测和定位内存泄漏？”（例如：Chrome DevTools 的 Performance 和 Memory 面板）
“let 和 const 的出现，在多大程度上影响了我们对闭包的使用和理解？”（块级作用域使得在循环中不再需要 IIFE 来创建闭包了）
“你能解释一下 V8 引擎是如何优化闭包的吗？”（涉及到上下文（Context）和闭包对象（Closure Object）的优化，这是一个加分项）