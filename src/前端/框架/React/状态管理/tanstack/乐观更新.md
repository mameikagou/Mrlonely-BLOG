### 乐观更新的场景

你以为的场景：

用户点击“删除”。

UI（乐观）：列表项消失。

API：失败（500 Error）。

UI（回滚）：列表项重新出现。

你：“这不就完事了吗？用 toast 提示‘删除失败’。”

我：“从‘消失’到‘出现’，这就叫**‘闪烁’**！这已经是很糟糕的体验了。”

真实的“B端噩梦”场景：

用户点击“删除 A”。

UI（乐观）：A 消失。

用户立刻操作，点击“修改 B”。

UI（乐观）：B 变成 B+。

此时，API (1)（删除 A）失败了！

API (2)（修改 B）成功了！

现在，你（作为“自制库”的作者）来回答我：

你是不是要“回滚” A？

你要不要“回滚” B？（B 可是成功了！）

你的“全局 Map 缓存”是怎么处理这种**“部分成功、部分失败”的“状态依赖链”**的？

Tanstack Query 和 SWR 内部有复杂的状态机来处理这种“队列”和“回滚”，你那个 10
秒钟就清空的“全局 Map”呢？

interview 自定义 Gem
你对技术的理解，还停留在**“依葫芦画瓢”**的阶段。你只知道“是什么”，你根本不知道“为什么”。

你这种状态，我（面试官）只要 3 个“为什么”，就能把你“拷打”得体无完肤。

1. 关于 ESLint：“格式化” vs “语法检查” 你是不是把 ESLint（代码质量）和
   Prettier（代码格式）搞混了？

Prettier 才是你说的“格式化”，它只管“逗号、分号、空格”，一键 format
就完了，这没有技术含量。

ESLint 管的是**“代码逻辑”和“潜在错误”**！

在你那个 React 15 的“屎山”里，ESLint 报的不是“格式问题”，而是：

react/no-deprecated-lifecycle：你还在用 componentWillMount，这是错误！

no-unused-vars：你定义了变量却没用，这是冗余！

no-console：你线上的代码还在打 console.log，这是泄露！

@typescript-eslint/no-explicit-any：你满屏的 any 类型，TS 等于白用！

你告诉我，这些 Error，你是能“直接 format 统一一下”就完事了吗？

这必须得人（Developer）去改！

“迁移指南”的价值，就是我上次说的：它安抚了那些“老员工”的情绪，告诉他们**“你不需要一次性改完
50 个 no-any 错误，你只需要把你这次碰到的 2 个改了就行”**。

这叫**“管理历史技术债务”，而不是“统一代码格式”。你连问题的严重性**都没搞懂。

2. 关于“自制 Tanstack Query”：你这是在“自杀” 你对“乐观更新”的理解，天真到可笑。

“回滚的时候使用缓存即可...为什么会闪烁？”
我来告诉你为什么会闪烁，因为你没想过“连续操作”。

你以为的场景：

用户点击“删除”。

UI（乐观）：列表项消失。

API：失败（500 Error）。

UI（回滚）：列表项重新出现。

你：“这不就完事了吗？用 toast 提示‘删除失败’。”

我：“从‘消失’到‘出现’，这就叫**‘闪烁’**！这已经是很糟糕的体验了。”

真实的“B端噩梦”场景：

用户点击“删除 A”。

UI（乐观）：A 消失。

用户立刻操作，点击“修改 B”。

UI（乐观）：B 变成 B+。

此时，API (1)（删除 A）失败了！

API (2)（修改 B）成功了！

现在，你（作为“自制库”的作者）来回答我：

你是不是要“回滚” A？

你要不要“回滚” B？（B 可是成功了！）

你的“全局 Map 缓存”是怎么处理这种**“部分成功、部分失败”的“状态依赖链”**的？

Tanstack Query 和 SWR 内部有复杂的状态机来处理这种“队列”和“回滚”，你那个 10
秒钟就清空的“全局 Map”呢？

“关于数据一致性...两个标签页，这就是两码事了吧？” 这怎么是两码事？！ 这恰恰是
Tanstack Query 这种库最有价值的场景之一！

你连 Tanstack Query 是**“服务端状态 (Server State)”** 管理库都不知道吗？

场景： 用户在 A 标签页（订单列表）看到了一个“待支付”订单。他打开了 B
标签页（详情页），把这个订单支付了。

问题： 他切回 A 标签页（订单列表）时，那个订单应该是什么状态？

你的“全局 Map”方案： 还是“待支付”。你的 A 标签页根本不知道 B 标签页干了什么。

Tanstack Query 方案： refetchOnWindowFocus = true（默认开启）。当用户切回 A
标签页，它会自动重新拉取数据，订单状态自动更新为“已支付”。

你连“服务端状态”和“客户端状态”的区别都没分清，你连它们的核心痛点（stale-while-revalidate、refetchOnWindowFocus、GC）都不知道，你还想“自制一个”？
