### 差分

差分跟前缀和，类似于积分和求导的关系

#### 什么是差分数组？
想象你有一个原始数组 A。它的差分数组 D 就是一个记录 A 中相邻元素之差的数组。
定义如下：
D[0] = A[0]
D[i] = A[i] - A[i-1] (对于 i > 0)
举个例子：
如果原始数组 A = [1, 5, 2, 8, 3]
那么它的差分数组 D 就是：
D[0] = A[0] = 1
D[1] = A[1] - A[0] = 5 - 1 = 4
D[2] = A[2] - A[1] = 2 - 5 = -3
D[3] = A[3] - A[2] = 8 - 2 = 6
D[4] = A[4] - A[3] = 3 - 8 = -5
所以，D = [1, 4, -3, 6, -5]

对差分求一遍前缀和就能还原出原数组。

差分数组：以下两个操作等价：
原数组为a[]
差分数组d[]
    - 对于a[], 从i到j，从左到右每个都 +x
    - 对于d[], a[i]+x 并且 a[j+1]-x 

### 扫描线算法

lc上这题要会员；
<https://www.lintcode.com/problem/919/>
<https://leetcode.cn/problems/meeting-rooms-ii/>
```md
给定一系列的会议时间间隔intervals，包括起始和结束时间[[s1,e1],[s2,e2],...] (si < ei)，找到所需的最小的会议室数量。

样例1

输入: intervals = [(0,30),(5,10),(15,20)]
输出: 2
解释:
需要两个会议室
会议室1:(0,30)
会议室2:(5,10),(15,20)
样例2

输入: intervals = [(2,7)]
输出: 1
解释:
只需要1个会议室就够了
```

##### 理解时间点 vs 时间段
会议 [start, end] 的含义是：
会议在 start 时刻开始。
会议在 end 时刻结束。
关键问题：在 end 这个精确的时间点，会议室是被占用的，还是已经空闲了？
答案：在 end 时刻，会议已经结束，会议室空闲了。它可以立刻被一个从 end 时刻开始的新会议使用。

```js
const minMeetingRooms = (intervals) => {
    if (!intervals || intervals.length === 0) {
        return 0;
    }

    const events = [];

    for(const [start, end] of intervals){
        events.push([start, 1]);
        events.push([end, -1]);
    }

    events.sort((a,b)=>{
        if(a[0]!==b[0]){
            return a[0] - b[0];
        }else{
            return a[1] - b[1]; // -1在前
        }
    })

    let curRoom = 0;
    let maxRoom = 0;

    for(const event of events){
        curRoom += events[1];
        maxRoom = Math.max(maxRoom, curRoom);
    }
    return maxRoom;
}
```

1. 力扣 56. 合并区间 (免费)
```js
var merge = function(intervals) {
    // 判空
    if(intervals.length===0) return intervals;
    // 排序
    const sortedIntervals = intervals.sort((a,b)=>a[0]-b[0]);
    // 初始化结果
    let result = [sortedIntervals[0]];
    // 遍历
    for(let i=0;i<sortedIntervals.length;i++){
        // 结果数组的最后一个，的右边界，要小于当前处理对象的左边界。就说明二者有重合，要合并。合并方式是更新更大的右边界。否则二者不重合，直接推就行。
        const last = result[result.length-1];
        const cur = sortedIntervals[i];

        if(cur[0] <= last[1]){
            last[1] = Math.max(last[1], cur[1])
        }else{
            result.push(cur);
        }
    }

    return result;
};
```
2. 力扣 452. 用最少数量的箭引爆气球 (免费)


```md
452. 用最少数量的箭引爆气球
有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。

一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。

给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。

 
示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：气球可以用2支箭来爆破:
-在x = 6处射出箭，击破气球[2,8]和[1,6]。
-在x = 11处发射箭，击破气球[10,16]和[7,12]。
示例 2：

输入：points = [[1,2],[3,4],[5,6],[7,8]]
输出：4
解释：每个气球需要射出一支箭，总共需要4支箭。
示例 3：

输入：points = [[1,2],[2,3],[3,4],[4,5]]
输出：2
解释：气球可以用2支箭来爆破:
- 在x = 2处发射箭，击破气球[1,2]和[2,3]。
- 在x = 4处射出箭，击破气球[3,4]和[4,5]。
 

提示:

1 <= points.length <= 105
points[i].length == 2
-231 <= xstart < xend <= 231 - 1
```

这题思路就是：

如果先按照结束位置排序
箭头至少为1
设置结束位

逻辑是： 新测试的区间的开始位，比上次测试的区间的结束位，要小；那么就有重合；就不需要加箭；

所以反过来，新区间的开始位，比上次测试的结束位，还大，就没有重合；需要加箭；

初始化：
```js
let arrows = 1
let end = points[0][1] // 上次测试的结束位置；后续循环从1开始，也就是第二个；
```

```ts
function findMinArrowShots(points: number[][]): number {
    if(points.length ===0) return 0
    points.sort((a,b)=>a[1]-b[1])
    let arrows = 1;
    let end = points[0][1]

    for(let i=1;i<points.length;i++){
        if(points[i][0] > end){
            arrows++
            end = points[i][1]
        }
    }
    return arrows;
};
```
3. 力扣 435. 无重叠区间 (免费)


#### 1094. 拼车
https://leetcode.cn/problems/car-pooling/

跟会议室2是一样的

```js
var carPooling = function(trips, capacity) {
    let events = [];

    for(let [passengers,from,to] of trips){
        events.push([from, passengers]);
        events.push([to, -passengers]);
    }

    events.sort((a,b)=>{
        if(a[0]!==b[0]){
            return a[0]-b[0];
        }else{
            return a[1]-b[1];
        }
    })
    let cur = 0;
    let max = 0;

    for(let event of events){
        cur += event[1];
        max = Math.max(cur, max);
    }
    if(max>capacity){
        return false;
    }
    return true;
};
```