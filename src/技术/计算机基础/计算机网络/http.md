
#### http

揭秘http2：<https://mp.weixin.qq.com/s/tG6HPSuGEOxpS9lq-Q_uLg>

##### http1.0

##### http1.1
在http1.1中，请求和响应采用串行处理，一个请求完成才能进入下一个请求，如果出现等待，则后续也要等待；

> 队头阻塞：一个请求或者响应阻塞，则后续请求或者响应也要阻塞；

通常会为浏览器开多个并行的tcp连接，带来额外的开销。

##### http2
http2牛逼在哪？ <https://xiaolincoding.com/network/2_http/http2.html>

基于https
完全基于tcp构建，
- 头部压缩
    - 采用hpack算法压缩头部，减少头部大小；（客户端和服务端同时维护一张表，后续只发送索引号）
- 二进制分帧
    - 头信息和数据体是分开传输的，通过帧的标志位来区分，并采用二进制格式编码
- 多路复用
    - 在同一个tcp连接中，引入了steam的概念，可以同时发送多个请求和响应，解决了http1.1的队头阻塞问题；
- 服务器推送（sse）

![二进制分帧](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/http2/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%B8%A7.png)

###### 多路复用

- Steam：一个连接中可以有多个stream，一个stream中可以有多个帧；
    - 帧：帧是http2中传输的最小单位，一个帧中包含帧头和帧体；
    - 帧头：帧头中包含帧的标志位、流标识符、长度等信息；
    - 帧体：帧体中包含请求或响应的数据；

并且，同一个stream中的帧可以乱序发送，每个都有一个唯一的steamId，接收方再自行组装。

###### 依然有队头阻塞的问题
http2通过多路复用的方式，解决了应用层的队头阻塞，但是在传输层，tcp协议本身存在队头阻塞的问题: 

所有http2流会被合并成单一字节流。
少量丢包，就会导致所有请求延迟（所有的包都必须等待这个包传回来）。
```text
TCP流: [A1][B1][C1][A2][B2][C2][A3][B3][C3]
                    ↑
              如果这个包丢失
                    ↓
所有后续包被阻塞: [A3][B3][C3] 必须等待 [B2] 重传
```


##### http3
